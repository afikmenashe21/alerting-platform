# Alerting Platform – Progress

## Decisions made
- Kafka for replay + at-least-once.
- Postgres for control-plane + notification idempotency boundary.
- Redis snapshot for evaluator warmup.
- Event contracts defined in protobuf (`proto/*.proto` + `pkg/proto`).

## Milestones
- [x] Topic contracts finalized (protobuf messages + sample payloads)
- [x] Postgres migrations: clients/rules (rule-service)
- [x] rule-service: CRUD + publish rule.changed
- [x] rule-updater: rebuild snapshot → Redis + bump version
- [x] evaluator: warmup + match + publish alerts.matched (one message per client_id)
- [x] aggregator: dedupe insert + publish notifications.ready
- [x] sender: consume notifications.ready + send via email (SMTP), Slack (webhook API), and webhook (HTTP POST) + update status
- [x] alert-producer: generate alerts + load tests
- [x] rule-service-ui: React UI for CRUD operations on clients, rules, and endpoints
- [x] **Production AWS Deployment (2026-01-21)**:
  - Terraform infrastructure for AWS ECS (EC2 launch type)
  - Dockerfiles for all 6 services (multi-stage builds with Go 1.22)
  - Docker images built and pushed to ECR
  - Full AWS stack deployed: VPC, ECS cluster, RDS Postgres, ElastiCache Redis, self-hosted Kafka
  - Ultra-low-cost configuration (~$15-20/month)
  - Increased Kafka partitions from 3 to 9
  - All 8 ECS services running
  - Deployment scripts: build-and-push.sh, update-services.sh
  - Comprehensive documentation in `docs/deployment/`
  - **Database Migration Completed (2026-01-21)**:
    - Created Docker-based migration solution (migrations/Dockerfile)
    - Built and pushed migration image to ECR
    - Ran as one-off ECS task with DB connection via environment variables
    - Successfully created all 4 tables: clients, endpoints, notifications, rules
    - Added SSM policy to ECS instance IAM role for future administrative access
    - Migration script: scripts/deployment/run-migration.sh
  - Note: Kafka topics still require initialization (9 partitions each)
  - **Memory Optimization (2026-01-22)**:
    - Fixed Kafka/Zookeeper memory issues causing OOM on t3.small
    - Reduced Zookeeper: 384MB→192MB task, 256MB→128MB heap
    - Reduced Kafka: 512MB→384MB task, 384MB→256MB heap
    - Reduced service containers: 256MB→180MB each
    - Total memory budget fits on single t3.small (~1656MB of 1700MB usable)
    - Configuration allows running entire stack on 1 instance for lowest cost
  - **Production Issues Resolved (2026-01-22)**:
    - Issue 1 - Kafka-Zookeeper Connection (18:00 UTC): ✅ FIXED
      - Restarted services in correct order
      - All services connected and stable
    - Issue 2 - Deployment Loop (20:50 UTC): ✅ FIXED
      - Removed ECS Docker health checks (Alpine images missing wget)
      - Updated task definition to revision 7
      - All services now 1/1 tasks, deployments COMPLETED
    - Key decisions: No ALB (cost savings), no health checks (not needed)
    - Documentation: DEPLOYMENT_ANALYSIS.md, DEPLOYMENT_FIX_SUMMARY.md, QUICK_STATUS.md
    - Kafka Topics: ✅ Created with 9 partitions (2026-01-22 19:13 UTC)
  - **Kafka Topics Created (2026-01-22 19:13 UTC)**:
    - All 4 topics created with 9 partitions for better parallelism
    - Topics: alerts.new, rule.changed, alerts.matched, notifications.ready
    - Used automated script: `increase-topic-partitions.sh`
    - Platform now ready for end-to-end testing
  - **Production Testing Completed (2026-01-22 19:35 UTC)**:
    - Created and ran production test scripts
    - Fixed security group to allow ephemeral ports (32768-65535) for ECS dynamic port mappings
    - Fixed task definition port mismatch (rule-service containerPort 8080 → 8081)
    - Updated Terraform port configurations (rule-service: 8081, alert-producer: 8082)
    - Verified all API endpoints: health, clients, rules, endpoints
    - Successfully created test data: client, rule, endpoint
    - Test script: `scripts/test/test-production.sh`
    - **Result**: ✅ Production environment fully operational
  - **Kafka Connectivity Fixed with DNS-Based Service Discovery (2026-01-22 20:10 UTC)**:
    - **Problem**: Hardcoded IP addresses caused connection failures when Kafka moved instances
    - **Solution**: Implemented AWS Cloud Map DNS-based service discovery
    - Created service discovery service: `kafka.alerting-platform-prod.local`
    - Combined Kafka + Zookeeper into single task (awsvpc mode)
    - Updated Kafka advertised listeners to use DNS name (no hardcoded IP)
    - Updated all consumer services (evaluator, rule-updater, aggregator, sender, rule-service) to use DNS
    - Verified: All 4 consumer groups connected with 0 errors
    - Documentation: `docs/deployment/KAFKA_FIX_SUMMARY.md`
    - **Result**: ✅ Fully automated, zero-configuration Kafka connectivity that survives instance changes

## Code health
- [x] rule-service: comprehensive code cleanup and modularization:
  - Removed redundant code via private helpers (validation, HTTP, JSON parsing)
  - Modularized handlers: split 674-line `handlers.go` into resource-specific files:
    - `clients.go`, `rules.go`, `endpoints.go`, `notifications.go`
  - Modularized database: split 716-line `database.go` into resource-specific files:
    - `types.go`, `db.go`, `clients.go`, `rules.go`, `endpoints.go`, `notifications.go`
  - Modularized router: split 180-line `router.go` into:
    - `router.go`, `routes.go`, `middleware.go`, `server.go`
  - Modularized producer: split 194-line `producer.go` into:
    - `producer.go`, `topic.go`
  - Added `publishRuleChangedEvent()` helper to reduce duplication
  - All rule-service tests pass; behavior unchanged.
- [x] rule-updater: code cleanup and modularization:
  - Split 618-line `snapshot.go` into three focused files:
    - `snapshot.go` (267 lines): Core Snapshot struct and in-memory operations
    - `writer.go` (156 lines): Writer struct and Redis operations
    - `lua_scripts.go` (207 lines): Lua script constants for direct Redis updates
  - Extracted redundant code into helper functions:
    - `getMaxDictValue()`: Reusable dictionary max value calculation
    - `removeFromIndex()`: Unified index removal logic
    - `newEmptySnapshot()`: Centralized empty snapshot creation
  - All tests pass; behavior unchanged.
- [x] sender: code cleanup and modularization:
  - Extracted duplicate `isValidURL` function from `slack.go` and `webhook.go` to shared `validation` package
  - Split 307-line `email.go` into three focused files:
    - `email.go` (164 lines): Main sender struct, configuration, and Send method
    - `smtp.go` (118 lines): TLS connection handling
    - `message.go` (40 lines): Email message building
  - All sender tests pass; behavior unchanged.
- [x] evaluator: code cleanup and modularization:
  - Extracted shared Kafka utilities to `internal/kafka/util.go`:
    - `ValidateConsumerParams()`: Common validation for brokers, topic, groupID
    - `ValidateProducerParams()`: Common validation for brokers, topic
    - `NewReaderConfig()`: Standardized Kafka reader configuration
  - Removed duplicate validation logic from `consumer`, `ruleconsumer`, and `producer` packages
  - Added `NewAlertMatched()` helper in `internal/events/events.go` to build AlertMatched from AlertNew
  - Simplified processor code by using helper function instead of inline struct construction
  - All evaluator tests pass; behavior unchanged.
- [x] aggregator: code cleanup and modularization:
  - Extracted shared Kafka utilities to `internal/kafka/kafka.go`:
    - `ValidateConsumerParams()`: Common validation for brokers, topic, groupID
    - `ValidateProducerParams()`: Common validation for brokers, topic
    - `NewReaderConfig()`: Standardized Kafka reader configuration
    - Constants: `ReadTimeout`, `CommitInterval`, `WriteTimeout`
  - Removed duplicate validation logic from `consumer` and `producer` packages
  - Extracted `buildMessage()` helper from producer for message construction
  - Extracted `marshalContextToJSONB()` helper from database for JSON marshaling
  - Added `NewNotificationReady()` helper in `internal/events/events.go` to build NotificationReady from AlertMatched
  - Simplified processor code by using helper function instead of inline struct construction
  - All aggregator tests pass; behavior unchanged.
- [x] alert-producer: code cleanup and modularization:
  - Extracted redundant code patterns into shared helpers:
    - `internal/processor/helpers.go`: Context cancellation checks, error handling, progress logging helpers
    - Removed duplicate error handling and logging code across processor modes
  - Split large files by resource/concern:
    - `processor.go` (469 lines) → split into 5 files: processor.go, burst.go, continuous.go, test.go, helpers.go
    - `job.go` (298 lines) → split into job.go (management) and executor.go (execution)
    - `handlers.go` (324 lines) → split into 5 files: types.go, generate.go, job_handlers.go, health.go, helpers.go
    - `producer.go` (288 lines) → split into producer.go and topic.go
  - All alert-producer tests pass; behavior unchanged.
- [x] rule-service: additional code cleanup and modularization:
  - Extracted common error handling patterns:
    - `internal/handlers/errors.go`: `handleDBError()` helper for consistent database error handling
    - `validateRuleFields()` and `validateRuleValues()` helpers for rule validation
    - Removed duplicate error handling code across all handlers (clients, rules, endpoints)
  - Split large files by concern:
    - `rules.go` (304 lines) → split into rules.go (handlers) and rules_events.go (event publishing helpers)
  - All rule-service tests pass; behavior unchanged.
- [x] sender: additional code cleanup and modularization:
  - Split large files by resource/concern:
    - `cmd/sender/main.go` (209 lines) → split into main.go (initialization) and processor.go (processing loop)
    - `internal/database/database.go` (220 lines) → split into database.go (connection), notifications.go (notification operations), and endpoints.go (endpoint operations)
  - All sender tests pass; behavior unchanged.
- [x] rule-updater: additional code cleanup and modularization:
  - Split large files by concern:
    - `internal/snapshot/snapshot.go` (267 lines) → split into snapshot.go (types and helpers), builder.go (BuildSnapshot), and operations.go (AddRule, UpdateRule, RemoveRule)
    - Extracted helper functions: `addToIndex()`, `addToDictionaries()`, `addToIndexes()` to reduce duplication
  - All rule-updater tests pass; behavior unchanged.
- [x] rule-service: additional database code cleanup:
  - Extracted redundant scanning patterns from `internal/database/rules.go`:
    - `scanRule()`: Helper function to scan a rule from sql.Row or sql.Rows (used by GetRule, ListRules, GetRulesUpdatedSince, UpdateRule, ToggleRuleEnabled, CreateRule)
    - `checkRuleVersionMismatch()`: Helper function for version mismatch checking (used by UpdateRule and ToggleRuleEnabled)
  - Reduced code duplication by ~40 lines across rule database operations
  - All rule-service tests pass; behavior unchanged.

## Recent Decisions
- **Evaluator output format**: One message per client_id (not one message with all matches)
  - Enables tenant locality: messages partitioned by client_id
  - Simplifies aggregator: one client per message
  - If alert matches N clients, N messages are published

- **Sender service design**: Multi-channel sender supporting email (SMTP), Slack (Incoming Webhooks), and webhooks (HTTP POST)
  - Queries endpoints table for all endpoint types (email, slack, webhook) by rule_ids
  - Routes to appropriate sender based on endpoint type
  - Email: SMTP protocol with configurable server (defaults to localhost:1025 for local dev)
  - Slack: Incoming Webhooks API with formatted messages and severity-based color coding
  - Webhook: HTTP POST with JSON payload containing full notification details
  - Idempotent: checks status before sending, updates after
  - At-least-once delivery: safe to redeliver (skips if already SENT)
  - Partial failures are logged but don't fail operation if at least one channel succeeds

- **rule-service-ui**: React + Vite UI for rule-service management
  - Full CRUD operations for clients, rules, and endpoints
  - Modern UI with tabbed navigation
  - Connects to rule-service API at http://localhost:8081 (via Vite proxy)
  - Features: create, read, update, delete, toggle enable/disable for all entities
  - Optimistic locking support for rule updates (version field)

- **Centralized Infrastructure Management**: Created unified dependency management
  - Root `docker-compose.yml` for shared infrastructure (Postgres, Kafka, Redis, Zookeeper)
  - Centralized verification script (`scripts/infrastructure/verify-dependencies.sh`)
  - Centralized migration runner (`scripts/migrations/run-migrations.sh`)
  - Centralized Kafka topic creation (`scripts/infrastructure/create-kafka-topics.sh`)
  - Services should verify dependencies, NOT manage them
  - `make run-all` automatically starts infrastructure if not running (one-command startup)
  - See `docs/architecture/INFRASTRUCTURE.md` for full documentation

- **Security: Email Credentials**: Removed all hardcoded email credentials from documentation
  - Replaced hardcoded Gmail credentials in `GMAIL_SETUP.md`, `README.md`, and `TROUBLESHOOTING.md` with placeholders
  - Created `.env.example` template file for secure credential management
  - Code already uses environment variables correctly (no code changes needed)
  - All credentials must now be provided via environment variables or `.env` file
  - `.env` files are already in `.gitignore` to prevent accidental commits

- **UI Integration for alert-producer (Planned)**: Integration with rule-service-ui for alert generation
  - HTTP API wrapper around alert-producer functionality
  - New UI component in rule-service-ui for generating alerts
  - Support for all CLI configuration options via web interface
  - Real-time status monitoring and job tracking
  - Preset configurations and manual configuration options
  - See `services/alert-producer/memory-bank/` for detailed design

- **Protobuf Integration (Complete)**: All Kafka topics migrated from JSON to protobuf
  - Created protobuf definition files (`proto/` directory):
    - `common.proto`: Shared enums (Severity, RuleAction)
    - `alerts.proto`: AlertNew and AlertMatched messages
    - `rules.proto`: RuleChanged message
    - `notifications.proto`: NotificationReady message
  - Generated Go code in `pkg/proto/` with proper module setup
  - All 6 services migrated to use protobuf serialization:
    - alert-producer: publishes AlertNew with proto.Marshal
    - evaluator: consumes AlertNew, publishes AlertMatched
    - aggregator: consumes AlertMatched, publishes NotificationReady
    - rule-service: publishes RuleChanged
    - rule-updater: consumes RuleChanged
    - sender: consumes NotificationReady
  - Enhanced tooling (added 2026-01):
    - Makefile targets: `proto-generate`, `proto-validate`, `proto-lint`, `proto-breaking`, `proto-verify-generated`
    - Buf configuration (`buf.yaml`) for linting and breaking change detection
    - Verification script to ensure generated code stays current
    - GitHub Actions workflow for CI validation
    - Pre-commit hooks for local validation
    - CI Fix (2026-01-21): Improved buf detection in Makefile to work with GitHub Actions buf-action by using `which` instead of `command -v`
    - CI Fix (2026-01-21): Fixed proto verification script to use buf instead of protoc for consistency with proto-generate target, eliminating false negatives in CI
  - Severity enum alignment (2026-01-21):
    - Fixed severity type mismatch between protobuf enums and database strings
    - Changed protobuf enum values to match database format directly: `LOW`, `MEDIUM`, `HIGH`, `CRITICAL` (removed `SEVERITY_` prefix)
    - In Go: `pbcommon.Severity_LOW`, `.String()` returns `"LOW"` - direct match with database
    - Simpler code: no conversion helpers needed, single source of truth
    - This ensures rule matching works correctly (was causing "No rules matched alert" errors)
  - Comprehensive documentation:
    - Strategy: `docs/architecture/PROTOBUF_INTEGRATION_STRATEGY.md`
    - Tooling: `docs/architecture/PROTOBUF_TOOLING.md`
    - Usage guide: `proto/README.md`
  - Benefits: Binary serialization, type safety, schema evolution, reduced message size
